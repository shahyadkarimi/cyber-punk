import { NextRequest, NextResponse } from "next/server";
import connectDB from "@/lib/connectDB";
import Exploits from "@/models/ExploitsModel";
import { getAuthUser } from "@/lib/auth";
import { createExploitSchema } from "@/lib/validation";

export async function POST(request: NextRequest) {
  try {
    await connectDB();

    const authUser = await getAuthUser(request);

    if (!authUser) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }

    if (authUser.role !== "admin") {
      return NextResponse.json({ error: "Forbidden" }, { status: 403 });
    }

    const body = await request.json();

    const result = createExploitSchema
      .partial({ id: true })
      .safeParse(body);

    if (!result.success) {
      const message = result.error.errors[0]?.message || "Invalid input.";
      return NextResponse.json({ error: message }, { status: 400 });
    }

    const {
      name,
      description,
      code,
      target_system,
      cve_id,
      severity,
      tags,
      is_verified,
    } = result.data;

    const exists = await Exploits.findOne({
      name: name.trim(),
    });

    if (exists) {
      return NextResponse.json(
        {
          error: "An exploit with this name already exists.",
        },
        { status: 409 }
      );
    }

    const newExploit = await Exploits.create({
      name,
      description,
      code,
      target_system,
      cve_id: cve_id?.trim() || null,
      severity,
      tags,
      is_verified,
      author_id: authUser.userId,
    });

    return NextResponse.json(
      { message: "Exploit successfully submitted.", exploit: newExploit },
      { status: 201 }
    );
  } catch (error) {
    console.error("Exploit creation error:", error);
    return NextResponse.json(
      { error: "An unexpected error occurred while submitting the exploit." },
      { status: 500 }
    );
  }
}
