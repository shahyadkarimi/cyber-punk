import { getVulnerabilitiesByCMS, getPluginsByCMS, type Vulnerability } from "./vulnerability-database"

export interface ScanResult {
  url: string
  cmsType: string
  cmsVersion?: string
  vulnerabilities: Vulnerability[]
  users: User[]
  themes: Theme[]
  plugins: Plugin[]
  scanTime: number
  errorMessage?: string
}

export interface User {
  username: string
  role?: string
  displayName?: string
  url?: string
}

export interface Theme {
  name: string
  version?: string
  active?: boolean
  vulnerabilities?: any[]
}

export interface Plugin {
  name: string
  slug?: string
  version?: string
  active?: boolean
  vulnerabilities?: any[]
}

/**
 * Main vulnerability scanner function
 */
export async function scanWebsite(url: string, selectedCms?: string): Promise<ScanResult> {
  const startTime = Date.now()
  let result: ScanResult = {
    url,
    cmsType: selectedCms || "Unknown",
    vulnerabilities: [],
    users: [],
    themes: [],
    plugins: [],
    scanTime: 0,
    errorMessage: undefined,
  }

  try {
    // Clean the URL
    url = url.replace(/^https?:\/\//, "")

    // Detect CMS if not provided
    if (!selectedCms) {
      const cmsInfo = await detectCMS(url)
      result.cmsType = cmsInfo.cmsType
      result.cmsVersion = cmsInfo.cmsVersion
    }

    // Get potential vulnerabilities based on CMS type
    result.vulnerabilities = getVulnerabilitiesByCMS(result.cmsType)

    // Scan for CMS-specific information
    switch (result.cmsType.toLowerCase()) {
      case "wordpress":
        const wpResult = await scanWordPress(url)
        result = { ...result, ...wpResult }
        break
      case "joomla":
        const joomlaResult = await scanJoomla(url)
        result = { ...result, ...joomlaResult }
        break
      case "drupal":
        const drupalResult = await scanDrupal(url)
        result = { ...result, ...drupalResult }
        break
      case "magento":
        const magentoResult = await scanMagento(url)
        result = { ...result, ...magentoResult }
        break
      case "laravel":
        const laravelResult = await scanLaravel(url)
        result = { ...result, ...laravelResult }
        break
      default:
        // Generic scan for unknown CMS
        const genericResult = await scanGeneric(url)
        result = { ...result, ...genericResult }
    }

    // Calculate scan time
    result.scanTime = Date.now() - startTime

    return result
  } catch (error) {
    console.error("Error in vulnerability scanner:", error)
    return {
      ...result,
      scanTime: Date.now() - startTime,
      errorMessage: error instanceof Error ? error.message : "Unknown error occurred during scanning",
    }
  }
}

/**
 * Detect CMS type and version
 */
async function detectCMS(url: string): Promise<{ cmsType: string; cmsVersion?: string }> {
  try {
    // Try both http and https
    let content = ""
    let protocol = "http"

    try {
      const httpResponse = await fetch(`http://${url}`, {
        method: "GET",
        headers: {
          "User-Agent":
            "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36",
        },
        signal: AbortSignal.timeout(5000),
      })

      if (httpResponse.ok) {
        content = await httpResponse.text()
        protocol = "http"
      }
    } catch (error) {
      // Silently fail and try https
    }

    if (!content) {
      try {
        const httpsResponse = await fetch(`https://${url}`, {
          method: "GET",
          headers: {
            "User-Agent":
              "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36",
          },
          signal: AbortSignal.timeout(5000),
        })

        if (httpsResponse.ok) {
          content = await httpsResponse.text()
          protocol = "https"
        }
      } catch (error) {
        // Silently fail
      }
    }

    if (!content) {
      return { cmsType: "Unknown" }
    }

    // Check for WordPress
    if (
      content.includes("wp-content") ||
      content.includes("wp-includes") ||
      content.includes("WordPress") ||
      content.includes("wp-")
    ) {
      // Try to get WordPress version
      const versionMatch = content.match(/meta name="generator" content="WordPress ([0-9.]+)"/i)
      const version = versionMatch ? versionMatch[1] : undefined

      return { cmsType: "WordPress", cmsVersion: version }
    }

    // Check for Joomla
    if (
      content.includes("joomla") ||
      content.includes("Joomla") ||
      content.includes("/administrator/") ||
      content.includes("com_content")
    ) {
      // Try to get Joomla version
      const versionMatch = content.match(/meta name="generator" content="Joomla! ([0-9.]+)"/i)
      const version = versionMatch ? versionMatch[1] : undefined

      return { cmsType: "Joomla", cmsVersion: version }
    }

    // Check for Drupal
    if (content.includes("drupal") || content.includes("Drupal") || content.includes("sites/all/modules")) {
      // Try to get Drupal version
      const versionMatch = content.match(/meta name="Generator" content="Drupal ([0-9.]+)"/i)
      const version = versionMatch ? versionMatch[1] : undefined

      return { cmsType: "Drupal", cmsVersion: version }
    }

    // Check for Magento
    if (content.includes("Magento") || content.includes("mage/") || content.includes("Mage.")) {
      return { cmsType: "Magento" }
    }

    // Check for Laravel
    if (content.includes("laravel") || content.includes("Laravel") || content.includes("csrf-token")) {
      return { cmsType: "Laravel" }
    }

    // Additional checks for other CMS types can be added here

    return { cmsType: "Unknown" }
  } catch (error) {
    console.error("Error detecting CMS:", error)
    return { cmsType: "Unknown" }
  }
}

/**
 * Scan WordPress website
 */
async function scanWordPress(url: string): Promise<Partial<ScanResult>> {
  try {
    const result: Partial<ScanResult> = {
      users: [],
      themes: [],
      plugins: [],
    }

    // Check for WordPress API endpoints
    try {
      // Try to get users via WP REST API
      const usersResponse = await fetch(`https://${url}/wp-json/wp/v2/users`, {
        method: "GET",
        headers: {
          "User-Agent":
            "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36",
        },
        signal: AbortSignal.timeout(5000),
      })

      if (usersResponse.ok) {
        const usersData = await usersResponse.json()
        if (Array.isArray(usersData)) {
          result.users = usersData.map((user) => ({
            username: user.slug,
            displayName: user.name,
            role: user.roles?.[0] || "unknown",
            url: user.link,
          }))
        }
      }
    } catch (error) {
      // Silently fail, API might be disabled
    }

    // Try to detect installed plugins
    try {
      const mainPageResponse = await fetch(`https://${url}`, {
        method: "GET",
        headers: {
          "User-Agent":
            "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36",
        },
        signal: AbortSignal.timeout(5000),
      })

      if (mainPageResponse.ok) {
        const content = await mainPageResponse.text()

        // Check for common WordPress plugins
        const knownPlugins = getPluginsByCMS("WordPress")
        const detectedPlugins: Plugin[] = []

        for (const plugin of knownPlugins) {
          // Check for plugin signatures in the HTML
          if (
            content.includes(`wp-content/plugins/${plugin.slug}`) ||
            content.includes(`plugins/${plugin.slug}`) ||
            content.includes(plugin.name.toLowerCase().replace(/\s+/g, "-"))
          ) {
            detectedPlugins.push({
              name: plugin.name,
              slug: plugin.slug,
              active: true,
              vulnerabilities: plugin.vulnerabilities,
            })
          }
        }

        result.plugins = detectedPlugins
      }
    } catch (error) {
      // Silently fail
    }

    // Try to detect active theme
    try {
      const mainPageResponse = await fetch(`https://${url}`, {
        method: "GET",
        headers: {
          "User-Agent":
            "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36",
        },
        signal: AbortSignal.timeout(5000),
      })

      if (mainPageResponse.ok) {
        const content = await mainPageResponse.text()

        // Look for theme path in HTML
        const themeRegex = /wp-content\/themes\/([^/]+)/i
        const themeMatch = content.match(themeRegex)

        if (themeMatch && themeMatch[1]) {
          result.themes = [
            {
              name: themeMatch[1].replace(/-/g, " "),
              active: true,
            },
          ]
        }
      }
    } catch (error) {
      // Silently fail
    }

    return result
  } catch (error) {
    console.error("Error scanning WordPress:", error)
    return {
      errorMessage: "Error scanning WordPress site",
    }
  }
}

/**
 * Scan Joomla website
 */
async function scanJoomla(url: string): Promise<Partial<ScanResult>> {
  try {
    const result: Partial<ScanResult> = {
      users: [],
      themes: [],
      plugins: [],
    }

    // Try to detect installed extensions
    try {
      const mainPageResponse = await fetch(`https://${url}`, {
        method: "GET",
        headers: {
          "User-Agent":
            "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36",
        },
        signal: AbortSignal.timeout(5000),
      })

      if (mainPageResponse.ok) {
        const content = await mainPageResponse.text()

        // Check for common Joomla extensions
        const knownExtensions = getPluginsByCMS("Joomla")
        const detectedExtensions: Plugin[] = []

        for (const extension of knownExtensions) {
          // Check for extension signatures in the HTML
          if (
            content.includes(`/components/${extension.slug}`) ||
            content.includes(`/${extension.slug}/`) ||
            content.includes(extension.name.toLowerCase().replace(/\s+/g, "-"))
          ) {
            detectedExtensions.push({
              name: extension.name,
              slug: extension.slug,
              active: true,
              vulnerabilities: extension.vulnerabilities,
            })
          }
        }

        result.plugins = detectedExtensions
      }
    } catch (error) {
      // Silently fail
    }

    // Try to detect template
    try {
      const mainPageResponse = await fetch(`https://${url}`, {
        method: "GET",
        headers: {
          "User-Agent":
            "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36",
        },
        signal: AbortSignal.timeout(5000),
      })

      if (mainPageResponse.ok) {
        const content = await mainPageResponse.text()

        // Look for template path in HTML
        const templateRegex = /templates\/([^/]+)/i
        const templateMatch = content.match(templateRegex)

        if (templateMatch && templateMatch[1]) {
          result.themes = [
            {
              name: templateMatch[1].replace(/-/g, " "),
              active: true,
            },
          ]
        }
      }
    } catch (error) {
      // Silently fail
    }

    return result
  } catch (error) {
    console.error("Error scanning Joomla:", error)
    return {
      errorMessage: "Error scanning Joomla site",
    }
  }
}

/**
 * Scan Drupal website
 */
async function scanDrupal(url: string): Promise<Partial<ScanResult>> {
  try {
    const result: Partial<ScanResult> = {
      users: [],
      themes: [],
      plugins: [],
    }

    // Try to detect installed modules
    try {
      const mainPageResponse = await fetch(`https://${url}`, {
        method: "GET",
        headers: {
          "User-Agent":
            "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36",
        },
        signal: AbortSignal.timeout(5000),
      })

      if (mainPageResponse.ok) {
        const content = await mainPageResponse.text()

        // Check for common Drupal modules
        const knownModules = getPluginsByCMS("Drupal")
        const detectedModules: Plugin[] = []

        for (const module of knownModules) {
          // Check for module signatures in the HTML
          if (
            content.includes(`/modules/${module.slug}`) ||
            content.includes(`/${module.slug}/`) ||
            content.includes(module.name.toLowerCase().replace(/\s+/g, "-"))
          ) {
            detectedModules.push({
              name: module.name,
              slug: module.slug,
              active: true,
              vulnerabilities: module.vulnerabilities,
            })
          }
        }

        result.plugins = detectedModules
      }
    } catch (error) {
      // Silently fail
    }

    // Try to detect theme
    try {
      const mainPageResponse = await fetch(`https://${url}`, {
        method: "GET",
        headers: {
          "User-Agent":
            "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36",
        },
        signal: AbortSignal.timeout(5000),
      })

      if (mainPageResponse.ok) {
        const content = await mainPageResponse.text()

        // Look for theme path in HTML
        const themeRegex = /themes\/([^/]+)/i
        const themeMatch = content.match(themeRegex)

        if (themeMatch && themeMatch[1]) {
          result.themes = [
            {
              name: themeMatch[1].replace(/-/g, " "),
              active: true,
            },
          ]
        }
      }
    } catch (error) {
      // Silently fail
    }

    return result
  } catch (error) {
    console.error("Error scanning Drupal:", error)
    return {
      errorMessage: "Error scanning Drupal site",
    }
  }
}

/**
 * Scan Magento website
 */
async function scanMagento(url: string): Promise<Partial<ScanResult>> {
  try {
    const result: Partial<ScanResult> = {
      users: [],
      themes: [],
      plugins: [],
    }

    // Try to detect Magento version and extensions
    try {
      const mainPageResponse = await fetch(`https://${url}`, {
        method: "GET",
        headers: {
          "User-Agent":
            "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36",
        },
        signal: AbortSignal.timeout(5000),
      })

      if (mainPageResponse.ok) {
        const content = await mainPageResponse.text()

        // Look for theme path in HTML
        const themeRegex = /skin\/frontend\/([^/]+)\/([^/]+)/i
        const themeMatch = content.match(themeRegex)

        if (themeMatch && themeMatch[2]) {
          result.themes = [
            {
              name: themeMatch[2].replace(/-/g, " "),
              active: true,
            },
          ]
        }
      }
    } catch (error) {
      // Silently fail
    }

    return result
  } catch (error) {
    console.error("Error scanning Magento:", error)
    return {
      errorMessage: "Error scanning Magento site",
    }
  }
}

/**
 * Scan Laravel website
 */
async function scanLaravel(url: string): Promise<Partial<ScanResult>> {
  try {
    const result: Partial<ScanResult> = {
      users: [],
      themes: [],
      plugins: [],
    }

    // Check for Laravel debug mode
    try {
      const errorPageResponse = await fetch(`https://${url}/non-existent-page-to-trigger-error`, {
        method: "GET",
        headers: {
          "User-Agent":
            "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36",
        },
        signal: AbortSignal.timeout(5000),
      })

      const content = await errorPageResponse.text()

      // Check if debug mode is enabled
      if (content.includes("Whoops\\Exception\\ErrorException") || content.includes("Laravel\\Framework")) {
        result.vulnerabilities = [
          {
            id: "LV-DEBUG-MODE",
            cmsType: "Laravel",
            name: "Laravel Debug Mode Enabled",
            description:
              "Laravel debug mode is enabled, which can expose sensitive information including environment variables and application secrets.",
            severity: "high",
            detectionPatterns: ["APP_DEBUG=true"],
            exploitAvailable: false,
          },
        ]
      }
    } catch (error) {
      // Silently fail
    }

    return result
  } catch (error) {
    console.error("Error scanning Laravel:", error)
    return {
      errorMessage: "Error scanning Laravel site",
    }
  }
}

/**
 * Generic scan for unknown CMS
 */
async function scanGeneric(url: string): Promise<Partial<ScanResult>> {
  try {
    const result: Partial<ScanResult> = {
      users: [],
      themes: [],
      plugins: [],
    }

    // Check for common vulnerabilities regardless of CMS
    try {
      // Check for exposed .git directory
      const gitResponse = await fetch(`https://${url}/.git/HEAD`, {
        method: "GET",
        headers: {
          "User-Agent":
            "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36",
        },
        signal: AbortSignal.timeout(3000),
      })

      if (gitResponse.ok) {
        const gitContent = await gitResponse.text()
        if (gitContent.includes("ref: refs/")) {
          result.vulnerabilities = [
            ...(result.vulnerabilities || []),
            {
              id: "GENERIC-GIT-EXPOSURE",
              cmsType: "Generic",
              name: "Exposed Git Repository",
              description:
                "The .git directory is publicly accessible, which can expose source code and sensitive information.",
              severity: "high",
              detectionPatterns: [".git/HEAD"],
              exploitAvailable: false,
            },
          ]
        }
      }
    } catch (error) {
      // Silently fail
    }

    // Check for directory listing
    try {
      const dirResponse = await fetch(`https://${url}/images/`, {
        method: "GET",
        headers: {
          "User-Agent":
            "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36",
        },
        signal: AbortSignal.timeout(3000),
      })

      if (dirResponse.ok) {
        const dirContent = await dirResponse.text()
        if (dirContent.includes("Index of /") || dirContent.includes("Directory Listing For")) {
          result.vulnerabilities = [
            ...(result.vulnerabilities || []),
            {
              id: "GENERIC-DIR-LISTING",
              cmsType: "Generic",
              name: "Directory Listing Enabled",
              description:
                "Directory listing is enabled, which can expose sensitive files and information about the website structure.",
              severity: "medium",
              detectionPatterns: ["Index of /"],
              exploitAvailable: false,
            },
          ]
        }
      }
    } catch (error) {
      // Silently fail
    }

    return result
  } catch (error) {
    console.error("Error in generic scan:", error)
    return {
      errorMessage: "Error performing generic scan",
    }
  }
}
