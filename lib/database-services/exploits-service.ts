import { supabase } from "@/lib/supabase"

export interface Exploit {
  id: string
  name: string
  description: string
  code: string
  target_system: string
  cve_id?: string | null
  severity: "low" | "medium" | "high" | "critical"
  author_id: string
  tags?: string[] | null
  is_verified: boolean
  created_at: string
  updated_at: string
  author?: {
    username: string
    email: string
  }
}

export interface ExploitInsert {
  name: string
  description: string
  code: string
  target_system: string
  cve_id?: string | null
  severity: "low" | "medium" | "high" | "critical"
  author_id: string
  tags?: string[]
  is_verified?: boolean
}

export interface ExploitUpdate {
  name?: string
  description?: string
  code?: string
  target_system?: string
  cve_id?: string | null
  severity?: "low" | "medium" | "high" | "critical"
  author_id?: string
  tags?: string[]
  is_verified?: boolean
}

export class ExploitsService {
  static async getAllExploits(): Promise<Exploit[]> {
    console.log("Fetching all exploits...")
    try {
      const { data, error } = await supabase
        .from("exploits")
        .select(`
          id,
          name,
          description,
          code,
          target_system,
          cve_id,
          severity,
          author_id,
          tags,
          is_verified,
          created_at,
          updated_at,
          author:users(username, email)
        `)
        .order("created_at", { ascending: false })

      if (error) {
        console.error("Error fetching all exploits:", error)
        throw error
      }

      console.log(`Successfully fetched ${data?.length || 0} exploits`)
      return data || []
    } catch (err) {
      console.error("Exception in getAllExploits:", err)
      throw err
    }
  }

  static async getExploitById(id: string): Promise<Exploit> {
    console.log(`Fetching exploit with ID: ${id}`)
    try {
      const { data, error } = await supabase
        .from("exploits")
        .select(`
          id,
          name,
          description,
          code,
          target_system,
          cve_id,
          severity,
          author_id,
          tags,
          is_verified,
          created_at,
          updated_at,
          author:users(username, email)
        `)
        .eq("id", id)
        .single()

      if (error) {
        console.error(`Error fetching exploit with ID ${id}:`, error)
        throw error
      }

      console.log("Successfully fetched exploit:", data?.name)
      return data
    } catch (err) {
      console.error(`Exception in getExploitById for ID ${id}:`, err)
      throw err
    }
  }

  static async getVerifiedExploits(): Promise<Exploit[]> {
    console.log("Fetching verified exploits...")
    try {
      const { data, error } = await supabase
        .from("exploits")
        .select(`
          id,
          name,
          description,
          code,
          target_system,
          cve_id,
          severity,
          author_id,
          tags,
          is_verified,
          created_at,
          updated_at,
          author:users(username, email)
        `)
        .eq("is_verified", true)
        .order("created_at", { ascending: false })

      if (error) {
        console.error("Error fetching verified exploits:", error)
        throw error
      }

      console.log(`Successfully fetched ${data?.length || 0} verified exploits`)
      return data || []
    } catch (err) {
      console.error("Exception in getVerifiedExploits:", err)
      throw err
    }
  }

  static async createExploit(exploit: ExploitInsert): Promise<Exploit> {
    console.log("Creating new exploit:", exploit.name)
    try {
      const exploitData = {
        name: exploit.name,
        description: exploit.description,
        code: exploit.code,
        target_system: exploit.target_system,
        cve_id: exploit.cve_id || null,
        severity: exploit.severity,
        author_id: exploit.author_id,
        tags: exploit.tags || [],
        is_verified: exploit.is_verified ?? false,
      }

      const { data, error } = await supabase
        .from("exploits")
        .insert(exploitData)
        .select(`
          id,
          name,
          description,
          code,
          target_system,
          cve_id,
          severity,
          author_id,
          tags,
          is_verified,
          created_at,
          updated_at,
          author:users(username, email)
        `)
        .single()

      if (error) {
        console.error("Error creating exploit:", error)
        throw error
      }

      console.log("Successfully created exploit:", data?.name)
      return data
    } catch (err) {
      console.error("Exception in createExploit:", err)
      throw err
    }
  }

  static async updateExploit(id: string, updates: ExploitUpdate): Promise<Exploit> {
    console.log(`Updating exploit with ID: ${id}`, updates)
    try {
      const { data, error } = await supabase
        .from("exploits")
        .update(updates)
        .eq("id", id)
        .select(`
          id,
          name,
          description,
          code,
          target_system,
          cve_id,
          severity,
          author_id,
          tags,
          is_verified,
          created_at,
          updated_at,
          author:users(username, email)
        `)
        .single()

      if (error) {
        console.error(`Error updating exploit with ID ${id}:`, error)
        throw error
      }

      console.log("Successfully updated exploit:", data?.name)
      return data
    } catch (err) {
      console.error(`Exception in updateExploit for ID ${id}:`, err)
      throw err
    }
  }

  static async deleteExploit(id: string): Promise<void> {
    console.log(`Deleting exploit with ID: ${id}`)
    try {
      const { error } = await supabase.from("exploits").delete().eq("id", id)

      if (error) {
        console.error(`Error deleting exploit with ID ${id}:`, error)
        throw error
      }

      console.log(`Successfully deleted exploit with ID: ${id}`)
    } catch (err) {
      console.error(`Exception in deleteExploit for ID ${id}:`, err)
      throw err
    }
  }

  static async verifyExploit(id: string, verified: boolean): Promise<Exploit> {
    console.log(`${verified ? "Verifying" : "Unverifying"} exploit with ID: ${id}`)
    return this.updateExploit(id, { is_verified: verified })
  }

  static async searchExploits(query: string): Promise<Exploit[]> {
    console.log(`Searching exploits with query: ${query}`)
    try {
      const { data, error } = await supabase
        .from("exploits")
        .select(`
          id,
          name,
          description,
          code,
          target_system,
          cve_id,
          severity,
          author_id,
          tags,
          is_verified,
          created_at,
          updated_at,
          author:users(username, email)
        `)
        .or(`name.ilike.%${query}%,description.ilike.%${query}%,target_system.ilike.%${query}%,cve_id.ilike.%${query}%`)
        .order("created_at", { ascending: false })

      if (error) {
        console.error(`Error searching exploits with query ${query}:`, error)
        throw error
      }

      console.log(`Successfully found ${data?.length || 0} exploits matching query: ${query}`)
      return data || []
    } catch (err) {
      console.error(`Exception in searchExploits for query ${query}:`, err)
      throw err
    }
  }

  static async refreshVerifiedExploits(): Promise<Exploit[]> {
    console.log("Refreshing verified exploits...")
    return this.getVerifiedExploits()
  }
}
